class Railway
types
	
values
-- TODO Define values here

instance variables

public trainCounter : nat := 0;
public railwayElements: seq of RailwayElement := [];
public trains: set of Train := {};


operations

-- adds a railwayelement to the end of the current sequence
	public appendRailwayElement: RailwayElement ==> ()
	appendRailwayElement(newRailwayElement) == (
		if (len railwayElements > 0) then (
		
			-- set elements ordering
			newRailwayElement.setCounterClockwiseElement(railwayElements(len railwayElements));
			railwayElements(len railwayElements).clockwiseElement := newRailwayElement;
		);
		
		-- add element to seq
		railwayElements := railwayElements ^ [newRailwayElement];
		
		if isofclass(Rail, newRailwayElement) then (
			IO`print("Added new rail.\n")
		) else (
			IO`print("Added new Station.\n")
		)
	)pre
		len railwayElements > 0 and isofclass(Station, newRailwayElement) => not isofclass(Station, railwayElements(len railwayElements))
post
		len railwayElements = (len railwayElements~ + 1) and
		len railwayElements > 1 => railwayElements(len railwayElements - 1).clockwiseElement = railwayElements(len railwayElements) and
		len railwayElements > 1 => railwayElements(len railwayElements).counterClockwiseElement = railwayElements(len railwayElements - 1);


--sets circular railway ( joins first with last )
public setCircularRailway: () ==> seq of RailwayElement
 setCircularRailway() == (
		railwayElements(len railwayElements).clockwiseElement := railwayElements(1);
		railwayElements(1).counterClockwiseElement := railwayElements(len railwayElements);
		IO`print("Closed Track.\n");
		
		return railwayElements;
	)
	post
		railwayElements(1).counterClockwiseElement = railwayElements(len railwayElements) and
		railwayElements(len railwayElements).clockwiseElement = railwayElements(1);

-- Places a new train in a station
	public placeTrainInStation: nat1 * Train`Direction * nat1 ==> Train
	placeTrainInStation(index, dir, stationIndex) == (
		dcl train: Train := new Train(index,dir);
		dcl tempSet: set of Train := {train};
		
		railwayElements(stationIndex).placeTrain(train);
		trains := trains union tempSet;
		
		return train;
		)pre isofclass(Station, railwayElements(stationIndex));
		
-- Places a new train in a rail
	public placeTrainInRail: nat1 * Train`Direction * nat1 ==> Train
	placeTrainInRail(index, dir, railIndex) == (
		dcl train: Train := new Train(index,dir);
		dcl tempSet: set of Train := {train};
		
		railwayElements(railIndex).placeTrain(train);
		trains := trains union tempSet;
		
		return train;
		)pre isofclass(Rail, railwayElements(railIndex));
		
-- Initializes all semaphores. It calls the corresponding subclass function for elements that are rails and stations
  public initAllSemaphores: () ==> ()
  initAllSemaphores() == (
  for all rail in set {r | r in set elems railwayElements & isofclass(Rail, r)} do (
			rail.initializeSemaphores()
		);
		for all station in set {s | s in set elems railwayElements & isofclass(Station, s)} do (
			station.initializeSemaphores()
		);
  );
  
-- Advances one iteration
	public advanceIt: set of Train ==> ()
		advanceIt(trains) == (
		dcl movedTrains: set of Train := {};
		dcl stopedTrains: set of Train;
		dcl startElem: RailwayElement;
		dcl finalElem: RailwayElement;
		
		for all train in set trains do (
			startElem := iota element in set elems railwayElements & element.checkTrain(train);
			if train.direction = <ClOCKWISE> then (finalElem := startElem.clockwiseElement;)
			else (finalElem := startElem.counterClockwiseElement;);
			if moveTrain(train, startElem, finalElem) then movedTrains := movedTrains union {train}
			else stopedTrains := stopedTrains union {train};
		);
		if card movedTrains > 0 then advanceIt(stopedTrains)
		else return;
		)
		pre
			card trains > 0 and len railwayElements > 1;

	
	public moveTrain: Train * RailwayElement * RailwayElement ==> bool
	moveTrain(train, startElem, finalElem) == (
		if (isofclass(Rail,startElem) and isofclass(Rail, finalElem))
		then return moveTrainRailToRail(train, startElem, finalElem);
		
		if (isofclass(Rail,startElem) and isofclass(Station, finalElem))
		then return moveTrainRailToStation(train, startElem, finalElem);
		
		if (isofclass(Station,startElem) and isofclass(Rail, finalElem))
		then return moveTrainStationToRail(train, startElem, finalElem);
		return false;
	)
		pre
			isofclass(Station,startElem) => isofclass(Rail,finalElem);
		
	public moveTrainRailToRail: Train * Rail * Rail ==> bool
		moveTrainRailToRail(train, startElem, finalElem) == (
		if train.direction = <ClOCKWISE> 
			then (
			if startElem.checkClockwiseSemaphoreIsRed() 
			then return false
			else (finalElem.placeTrain(train); 
						startElem.removeTrain(train);
						return true);)
		else(
			if startElem.checkCounterClockwiseSemaphoreIsRed() 
			then return false
			else (finalElem.placeTrain(train); 
						startElem.removeTrain(train);
						return true);)
		)
		pre
			startElem.train = train 
			and train.direction = <ClOCKWISE> => startElem.clockwiseElement = finalElem 
			and train.direction = <COUNTERCLOCKWISE> => startElem.counterClockwiseElement = finalElem
		
		post
			finalElem.train = train;

	public moveTrainRailToStation: Train * Rail * Station ==> bool
		moveTrainRailToStation(train, startElem, finalElem) == (
		if train.direction = <ClOCKWISE> 
			then (
			if startElem.checkClockwiseSemaphoreIsRed() 
			then return false
			else (finalElem.placeTrain(train); 
						startElem.removeTrain(train);
						return true);)
		else(
			if startElem.checkCounterClockwiseSemaphoreIsRed() 
			then return false
			else (finalElem.placeTrain(train); 
						startElem.removeTrain(train);
						return true);)
		)
		pre
			startElem.train = train 
			and train.direction = <ClOCKWISE> => startElem.clockwiseElement = finalElem 
			and train.direction = <COUNTERCLOCKWISE> => startElem.counterClockwiseElement = finalElem
		
		post
			(finalElem.clockwiseTrain = train or finalElem.counterClockwiseTrain =train);
			
	public moveTrainStationToRail: Train * Station * Rail ==> bool
		moveTrainStationToRail(train, startElem, finalElem) == (
		if train.direction = <ClOCKWISE> 
			then (
			if startElem.checkClockwiseSemaphoreIsRed() 
			then return false
			else (finalElem.placeTrain(train); 
						startElem.removeTrain(train);
						return true);)
		else(
			if startElem.checkCounterClockwiseSemaphoreIsRed() 
			then return false
			else (finalElem.placeTrain(train); 
						startElem.removeTrain(train);
						return true);)
		)
		pre
			(startElem.clockwiseTrain = train or startElem.counterClockwiseTrain =train)
			and train.direction = <ClOCKWISE> => startElem.clockwiseElement = finalElem 
			and train.direction = <COUNTERCLOCKWISE> => startElem.counterClockwiseElement = finalElem
		
		post
			finalElem.train = train;
			
  
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Railway